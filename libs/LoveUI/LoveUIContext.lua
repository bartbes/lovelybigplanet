--[[
Guide to LoveUI.Context.

Properties:
	--Property
		--[Example Values] description
		
		doubleClickSpeed
			[300] milliseconds multiple clicks must occur in betwen each other to count as unaryth click
		keyRepeatSpeed
			[300] how long to hold key before it counts as another keyDown
		setFirstResponder(aResponder)
			--set first responder. e.g setting a textfield as first responder puts it in focus.
		firstResponder
			readonly. get current first responder.
		plugin()
			
		
]]--
-- LoveUIContext.lua
-- Usually only one of these instances in a love app. The first one is auto-generated by LoveUI.
-- contains content views

-- A Context contains a contentView, which holds an array of subviews to be displayed on the screen. These views also receive mouse and key events directed to them from the Context.
local LoveUI=LoveUI
LoveUI.require("LoveUIStack.lua")
LoveUI.require("LoveUIGraphicsEnvironment.lua")
LoveUI.require("LoveUIEvent.lua")
LoveUI.require("LoveUIRect.lua")
LoveUI.require("LoveUIResponder.lua")
LoveUI.require("LoveUIView.lua")
LoveUI.Context=LoveUI.Responder:new();

function LoveUI.Context:init()
	-- e.g local o=LoveUI.Object:alloc():init();
	LoveUI.Responder.init(self);
	self.eventNumber=0;
	self.doubleClickSpeed=300;
		--two clicks at same spot within 300 ms is double click. 
	self.keyRepeatSpeed=300;
		--key held for 300 milis is repeat key.
	self.lastMouseEvent=nil;
	self.lastKeyEvent=nil;
	self.keysDown={};
	
	self.clickCount=1;
	local contentView=LoveUI.View:new(LoveUI.Rect:new(0,0,LoveUI.graphics.getWidth(), LoveUI.graphics.getHeight()));
	self.firstResponder=contentView;
	self:setContentView(contentView);
	
	self.contentView.context=self;
	self.contentView.opaque=false;
	self.graphicsEnvironmentStack=LoveUI.Stack:new();
	return self;
end


function LoveUI.Context:setFirstResponder(aResponder)
	if self.firstResponder:resignFirstResponder() then
		if aResponder:acceptsFirstResponder() then
		
			if aResponder:becomeFirstResponder() then
				
				self.firstResponder=aResponder
				return true
			end
		end
	end
	return false
end

function LoveUI.Context:plugin()
	-- e.g myContext:plugin()
	-- cannot be undone, useful when have a persistant context
	local oldmp=mousepressed;
	mousepressed=function(x, y, button, ...)
		self:mouseEvent(x, y, button, self.mouseDown)
		if type(oldmp)=="function" then
			return oldmp(x, y, button, ...)
		end
	end
	local oldmr=mousereleased;
	mousereleased=function(x, y, button, ...)
		self:mouseEvent(x, y, button, self.mouseUp)
		if type(oldmr)=="function" then
			return oldmr(x, y, button, ...)
		end
	end
	local oldkp=keypressed;
	keypressed=function(key, ...)
		self:keyEvent(key, self.keyDown)
		if type(oldkp)=="function" then
			return oldkp(key, ...)
		end
	end
	local oldkr=keyreleased;
	keyreleased=function(key, ...)
		self:keyEvent(key, self.keyUp)
		if type(oldkr)=="function" then
			return oldkr(key, ...)
		end
	end
	local olddraw=draw;
	draw=function(...)
		self:display()
		
		if type(olddraw)=="function" then
			return olddraw(...)
		end
	end
	local oldupdate=update;
	update=function(dt, ...)
		self:update(dt);
		if type(oldupdate)=="function" then
			return oldupdate(dt, ...)
		end
	end
end
function LoveUI.Context:update(dt)
	self:checkKeyRepeat();
	--self.contentView:update(dt);
	--self.contentView:updateSubviews(dt);
	LoveUI.pushMatrix()
	LoveUI.translate(self.firstResponder.frame.origin:get())
	self.firstResponder:update(dt);
	self.firstResponder:updateSubviews(dt);
	LoveUI.popMatrix()
end
function LoveUI.Context:keyEvent(key, call)
	-- to be plugged into mousepressed call back function
	local mouseLocation=LoveUI.Point:new(love.mouse.getX(), love.mouse.getY());
	local timestamp=LoveUI.time()
	local context=self
	
		local keysDown={}
		for k, v in pairs(self.keysDown) do
			keysDown[k]=v;
		end
		
	local theEvent=LoveUI.Event:keyEvent(mouseLocation, key, keysDown, timestamp, context, 1);
	call(self, theEvent)
	self.lastKeyEvent=theEvent;
end

function LoveUI.Context:checkKeyRepeat()
	if self.lastKeyEvent== nil then
		return nil;
	end
	if not love.keyboard.isDown(self.lastKeyEvent.keyCode) then
		return nil;
	end
	local timestamp=LoveUI.time()
	if timestamp-self.lastKeyEvent.timestamp >=self.keyRepeatSpeed then
			self:keyEvent(self.lastKeyEvent.keyCode, self.keyDown);
			self.keyRepeatSpeed=math.max(self.keyRepeatSpeed*0.5, 50);
	end
end

function LoveUI.Context:keyUp(theEvent)
	self.keyRepeatSpeed=300
	self.keysDown[theEvent.keyCode]=false;
	if self.lastKeyEvent~=nil and theEvent.keyCode==self.lastKeyEvent.keyCode then
		self.lastKeyEvent=nil;
	end
	if self.firstResponder~=nil then
		self.firstResponder:keyUp(theEvent);
	end
end

function LoveUI.Context:keyDown(theEvent)
	self.keysDown[theEvent.keyCode]=true;
	self.lastKeyEvent=theEvent;
	if self.firstResponder~=nil then
		self.firstResponder:keyDown(theEvent);
	end
end

function LoveUI.Context:mouseEvent(x, y, button, call)
	-- to be plugged into mousepressed call back function
	local location=LoveUI.Point:new(x, y);
	local timestamp=LoveUI.time()
	local context=self
	local eventNumber=context.eventNumber
	if self.lastMouseEvent~=nil then
		if timestamp-self.lastMouseEvent.timestamp <= self.doubleClickSpeed
			and self.lastMouseEvent.button==button and self.lastMouseEvent.mouseLocation:isEqual(location) then
			self.clickCount=self.clickCount+1;
		else
			self.clickCount=1;
		end
	end
		local keysDown={}
		for k, v in pairs(self.keysDown) do
			keysDown[k]=v;
		end
	local theEvent=LoveUI.Event:mouseEvent(location, button, keysDown, timestamp, context, eventNumber, self.clickCount);
	call(self, theEvent)
	
	self.lastMouseEvent=theEvent;
	context.eventNumber=context.eventNumber+1
end


function LoveUI.Context:reclick()
	if self.lastMouseEvent~=nil then
		self:mouseEvent(self.lastMouseEvent.mouseLocation.x, self.lastMouseEvent.mouseLocation.y, self.lastMouseEvent.button, self.mouseDown);
	else
		self:mouseEvent(love.mouse.getX(), love.mouse.getY(), 1, self.mouseDown);	
	end
end

function LoveUI.Context:setContentView(view)
	view:setNextResponder(nil)
	self.contentView=view;
	if self.firstResponder==nil then
		self:setFirstResponder(self.contentView)
	end
end

function LoveUI.Context:store()
	local genv=LoveUI.GraphicsEnvironment:new()
	self.graphicsEnvironmentStack:push(genv)
end

function LoveUI.Context:restore()
	local genv=self.graphicsEnvironmentStack:pop();
	genv:restore();
end

function LoveUI.Context:setScissorFrame(frame)
	LoveUI.graphics.setScissor(frame.origin.x, frame.origin.y, math.min(frame.size.width, w or frame.size.width), math.min(frame.size.height, h or frame.size.height));
end

function LoveUI.Context:display(dt)
	self:store()
	
	self.contentView:display(dt);
	self.contentView:displaySubviews(dt);
	
	self:restore()
end

function LoveUI.Context:addSubview(...)
	self.contentView:addSubview(...)
end

function LoveUI.Context:mouseDown(theEvent)
	local aView=self.firstResponder;
	if self.firstResponder:resignFirstResponder() then
		aView=self.contentView;
	end
	-- Now, find the front most view that is being hit by mouse.
	while aView~=nil do
		local subviews=aView.subviews;
		local viewmatched=false;
		if #subviews==0 then break end
		for k, v in pairs(subviews) do
			v=subviews[#subviews-k+1];
			if not v.hidden then
				if LoveUI.mouseInRect(theEvent.mouseLocation, self.contentView:convertRectFromView(v.frame, aView)) then
					-- theEvent's location is in contentView's coordinate system
					
					aView=v;
					aView:bringToFront();
					viewmatched=true;
					break;
				end
			end
		end
		if viewmatched==false then
			break
		end
	end
	
	if aView==nil then
		aView=self.contentView;
	end
	
	if self.firstResponder:resignFirstResponder() then
		if self:setFirstResponder(aView) then
			-- Forward thEvent to the responder
			aView:mouseDown(theEvent);
		end
	else
		self.firstResponder:mouseDown(theEvent);
	end
	
end

function LoveUI.Context:mouseUp(theEvent)
	if self.firstResponder~=nil then
		-- Forward thEvent to the responder
		self.firstResponder:mouseUp(theEvent)
		--if self.firstResponder:resignFirstResponder() then
			--self.firstResponder=self.contentView;
		--end
	end
end
